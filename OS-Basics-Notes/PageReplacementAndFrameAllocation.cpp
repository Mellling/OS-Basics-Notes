//////////////////////////////////////////////////////////
// [페이지 교체와 프레임 할당]
//////////////////////////////////////////////////////////

// 운영체제는 프로세스들이 한정된 메모리를 효율적으로 이용할 수 있도록

// 기존에 메모리에 적재된 불필요한 페이지를 선별하여 보조기억장치로 내보낼 수 있어야 하고,

// 프로세스들에 적절한 수의 프레임을 할당할 수 있어야 한다.

// [ 요구 페이징 ] /////////////////////////////////////////

// 프로세스를 메모리에 적재할 때 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만 메모리에 적재하는 기법을 요구 페이징이라 한다.

// 1. CPU가 특정 페이지에 접근하는 명령어를 실행한다.
// 2. 해당 페이지가 현재 메모리에 있을 경우(유효 비트가 1) CPU는 페이지가 적재된 프레임에 접근한다.
// 3. 해당 페이지가 현재 메모리에 없을 경우(유효 비트가 0) 페이지 폴트가 발생한다.
// 4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정한다.
// 5. 다시 1번을 수행한다.

// 아무런 페이지를 메모리에 적재하지 않고 무작정 실행할 수 있다.

// 이 경우 프로세스의 첫 실행 순간부터 페이지 폴트가 계속 발생하게 되고, 실행에 필요한 페이지가 어느 정도 적재된 이후부터는 페이지 폴트 발생 빈도가 떨어진다.

// 이를 순수 요구 페이징 기법이라 한다.

// 요구 페이징 기법이 안정적으로 작동하려면 페이지 교체와 프레임 할당이 해결되어야 한다.

//////////////////////////////////////////////////////////

// [ 페이지 교체 알고리즘 ] /////////////////////////////////

// 쫓아낼 페이지를 결정하는 방법을 페이지 교체 알고리즘이라 한다.

// 페이지 폴트가 가장 적게 일으키는 알고리즘을 좋은 페이지 교체 알고리즘이라 평가한다.

// 페이지 폴트가 발생하면 보조기억장치로부터 필요한 페이지를 가져와야 하기 때문에 메모리에 적재된 페이지를 가져와야 하기 때문에 메모리에 적재된 페이지를 가져오는 것보다 느려지기 때문이다.

// 페이지 참조열은 CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열을 의미한다.

// 중복된 페이지를 참조하는 행위는 페이지 폴트를 발생하지 않기 때문에 생락한다.

// 페이지 참조열을 통해 페이지 폴트 횟수를 알 수 있다.

//////////////////////////////////////////////////////////

// ## FIFO 페이지 교체 알고리즘 /////////////////////////////

// FIFO 페이지 교체 알고리즘은 메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식이다.

// 아이디어와 구현은 간단하지 자주 참조되는 페이지가 먼저 적재되었다는 이유만으로 내쫓길 수 있다.

// * 이를 보완하여 기회를 2번 주는, 2차 기회 페이지 교체 알고리즘도 있다.

//////////////////////////////////////////////////////////

// ## 최적 페이지 교체 알고리즘 //////////////////////////////

// 최적 페이지 교체 알고리즘은 CPU에 의해 참조되는 횟수를 고려하는 페이지 교체 알고리즘이다.

// 보조기억장치로 내보내야 할 페이지는 앞으로 사용 빈도가 가장 낮은 페이지이므로, 앞으로 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘이 가장 합리적이다.

// 최적 페이지 교체 알고리즘은 가장 낮은 페이지 폴트율을 보장하는 알고리즘이다.

// 다만, 최적 페이지 교체 알고리즘은 실제 구현이 어렵다.← 앞으로 오랫동안 사용하지 않을 페이지를 예측하기란 어렵다. (현실적으로 불가능)

// 따라서 최적 페이지 교체 알고리즘은 운영체제에서 사용하기보다는, 주로 다른 페이지 교체 알고리즘의 이론 성능을 평가하기 위한 목적으로 사용된다.

//////////////////////////////////////////////////////////

// ## LRU 페이지 교체 알고리즘 //////////////////////////////

// 가장 오랫동안 사용되지 않은 페이지를 교체하는 알고리즘 구현은 가능한데, 이 알고리즘이 LRU 페이지 교체 알고리즘이다.

// 이외에도 페이지 교체 알고리즘 종류는 매우 다양하며 위에 나온 세 개의 알고리즘은 페이지 교체 알고리즘의 대표적인 기본 아이디어라 보면 된다.

//////////////////////////////////////////////////////////

// [ 스래싱과 프레임 할당 ] /////////////////////////////////

// 프로세스가 사용할 수 있는 프레임 수가 적어도 페이지 폴트가 자주 발생한다.← 더 근본적인 이유

// 반대로 프로세스가 사용할 수 있는 프레임 수가 많으면 일반적으로 페이지 폴트 빈도가 감소한다.

// 페이지 폴트가 자주 발생하면 결과적으로 CPU의 이용률도 떨어진다.이처럼 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능을 저해되는 문제를 스래싱이라 한다.

// 멀티프로그래밍 정도란 메모리에 동시 실행되는 프로세스의 수이다.

// CPU 이용률 - 멀티프로그래밍 정도 그래프를 보면 동시에 실행되는 프로세스의 수를 늘린다고 해서 CPU 이용률이 그에 비례하여 증가하는 것이 아님을 나타낸다.

// 멀티프로그래밍 정도가 어느 정도 증가하면 CPU 이용률이 높아지지만, 필요 이상으로 늘리면 각 프로세스들이 사용할 수 있는 프레임 수가 적어지기 때문에 페이지 폴트가 지나치게 빈번히 발생한다.

//////////////////////////////////////////////////////////

// 스래싱이 발생하는 근본적인 원인은 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않고 있기 때문이다.

// → 운영체제는 각 프로세스들이 무리 없이 실행하기 위한 최소한의 프레임 수를 파악하고 프로세스들에 적절한 수만큼 프레임을 할당해 줄 수 있어야 한다.

// ## 정적 할당 방식 ///////////////////////////////////////

// 프로세스의 실행 과정을 고려하지 않고 단순히 프로세스의 크기와 물리 메모리의 크기만 고려하는 방식이다.

// - 균등 할당
//		- 모든 프로세스에 균등하게 프레임을 할당하는 방식이다.
//		- 실행되는 프로세스들의 크기는 각기 다른데 같은 양의 프레임을 할당하는 것은 비합리적이다.
// - 비례 할당
//		- 프로세스의 크기가 크면 프레임을 많이 할당하고, 크기가 작으면 프레임을 적게 할당하는 방식이다.
//		- 반드시 프로세스의 크기와 필요한 프레임의 크기가 비례하는 것은 아니다.

// ## 동적 할당 방식 ///////////////////////////////////////

// 프로세스의 실행을 보고 할당한 프레임의 수를 결정하는 방식이다.

// - 작업 집합 모델
//		- 프로세스가 일정 기간 동안 참조할 페이지 집합을 기억하여 빈번한 페이지 교체를 방지하는 방식이다.
//		- 실행 중인 프로세스가 일정 기간 동안 참조할 페이지의 집합을 작업 집합이라 한다.

// -페이지 폴드 빈도를 사용하는 방식
//		- 페이지 폴드율과 할당된 프레임 수는 반비례 관계이다.
//		- 페이지 폴드율에 상한선과 하한선을 정하고, 이 범위 안에서만 프레임을 할당하는 방식이다.