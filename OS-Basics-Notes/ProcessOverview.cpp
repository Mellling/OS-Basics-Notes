//////////////////////////////////////////////////////////
// [프로세스 개요]
//////////////////////////////////////////////////////////


// [ 프로세스 직접 확인하기 ] ////////////////////////////

// 프로세스는 사용자가 볼 수 있는 공간에서 실행되는 프로세스인 포그라운드 프로세스와 보이지 않는 곳에서 실행되는 프로세스 백그라운드 프로세스로 나누어진다.

// 백그라운드 프로세스 중 사용자가 직접 상호작용할 수 있는 백그라운드 프로세스도 있지만, 직접 상호작용하지 않고 그저 묵묵히 정해진 일만 수행하는 백그라운드 프로세스도 있다.

// 이러한 백그라운드 프로세스를 유닉스 계열의 운영체제(ex.리눅스)에서는 데몬이라 부르고, 윈도우 운영체제에서는 서비스라 부른다.

//////////////////////////////////////////////////////////


// [ 프로세스 제어 블록 ] ////////////////////////////////

// 모든 프로세스는 실행을 위해 CPU를 필요로 하지만 CPU 자원은 한정되어 있다.따라서 모든 프로세스가 CPU를 동시에 사용할 수는 없다.

// 그렇기에 프로세스들은 자신의 차례가 되면 정해진 시간만큼 CPU를 이용하고, 시간이 끝났음을 알리는 인터럽트(타이머 인터럽트*)가 발생하면 자신의 차례를 양보하고 다음 차례를 기다린다.

// * 타이머 인터럽트는 클럭 신호를 발생시키는 장치에 의해 주기적으로 발생하는 하드웨어 인터럽트이다.

// 운영체제는 빠르게 번갈아 수행되는 프로세스의 실행 순서를 관리하고, 프로세스에 CPU를 비롯한 자원을 배분한다.이를 위해 운영체제는 프로세스 제어 블록(PCB)을 이용한다.

// 프로세스 제어 블록은 프로세스와 관련된 정보를 저장하는 자료구조로, 커널 영역에 생성된다.

// 프로세스 제어 블록에는 해당 프로세스를 식별하기 위해 꼭 필요한 정보들이 저장되며, 운영체제는 수많은 프로세스들 사이에서 PCB로 특정 프로세스를 식별하고 해당 프로세스를 처리하는데 필요한 정보를 판단한다.

// PCB는 프로세스 생성 시에 만들어지고 실행이 끝나면 폐기된다.
// 다시 말해 새로운 프로세스가 생성되었다는 말은 운영체제가 PCB를 생성했다는 말과 같으며, 프로세스가 종료되었다는 말은 운영체제가 해당 PCB를 폐기했다는 말과 같다.

//////////////////////////////////////////////////////////


// PCB에 담기는 정보는 운영체제마다 다르지만, 대표적인 정보는 다음과 같다.

// - 프로세스 ID
//		- 프로세스 ID(PID)는 특정 프로세스를 식별하기 위해 부여하는 고유한 번호이다.
//		- 같은 일을 수행하는 프로세스라 하더라도 두 번 실행하면 PID가 다른 두 개의 프로세스가 생성된다.
// - 레지스터 값
//		- 프로세스는 자신의 실행 차례가 돌아오면 이전까지 사용했던 레지스터의 중간값 * 들을 모두 복원한다.
//		* 프로세스가 중단되었을 때의 레지스터 값
//		- 따라서 해당 프로세스가 실행하면 사용 중이던 프로그램 카운터를 비롯한 레지스터의 값이 저장되어 있다.
// - 프로세스 상태
//		- 현재 프로세스가 어떤 상태인지 또한 PCB 안에 기록되어야 한다.
//		- CPU 스케줄링 상태
//		- 프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보도 PCB에 기록된다.
// - 메모리 관리 정보
//		- 프로세스가 어느 주소에 저장되어 있는지에 대한 정보, 베이스 레지스터나 한계 레지스터 값과 같은 정보들이 담긴다.
//		- 프로세스의 주소를 알기 위한 또 다른 중요 정보 중 하나인 페이지 테이블 정보 또한 담긴다.
// - 사용할 파일과 입출력 장치 목록
//		- 프로세스가 실행 과정에서 특정 입출력장치나 파일을 사용하면 해당 내용이 PCB에 명시된다.


//////////////////////////////////////////////////////////


// [ 문맥 교환 ] /////////////////////////////////////////

// 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보를 문맥이라 한다.PCB에 기록되는 정보들이 문맥이라 봐도 무방하다.

// CPU 사용 시간이 끝났거나 혹은 예기치 못한 상황이 발생하여 인터럽트가 발생하면 운영체제는 해당 PCB를 백업하고, 뒤이어 실행해야 할 프로세스의 문맥을 복구한다.

// 이렇게 기존 프로세스의 PCB를 백업하고, 새로운 프로세스를 실행하기 위해 문맥을 PCB로 복구하여 새로운 프로세스를 실행하는 것을 문맥 교환이라 한다.


// 문맥 교환은 여러 프로세스가 끊임없이 번갈아 가며 실행되는 원리이다.문맥 교환이 너무 많이 발생하면 오버헤드가 발생할 수 있기에 자주 발생하는 것이 반드시 좋은 것은 아니다.

//////////////////////////////////////////////////////////


// [ 프로세스의 메모리 영역 ] ////////////////////////////

// 프로세스가 생성되면 커널 영역에는 PCB가 생성되며, 사용자 영역에는 크게 코드 영역, 데이터 영역, 힙 영역, 스택 영역으로 나뉘어 저장된다.


//  ## 코드 영역(텍스트 영역) ///////////////////////////

// 코드 영역은 기계어로 이루어진 명령어가 저장되는 공간이다.코드 영역에는 데이터가 아닌 CPU가 실행할 명령어가 담겨 있기 때문에 쓰기가 금지되어 있는, 읽기 전용 공간이다.

// 코드 영역은 데이터 영역과 함께 크기가 고정되어 있는 정적 할당 영역이다.

// 코드 영역 같은 경우 실행하는 동안 갑자기 프로그램을 구성하는 명령어들이 바뀔 일은 없기 때문이다.


// ## 데이터 영역 ///////////////////////////////////////

// 데이터 영역은 잠깐 썼다가 없앨 데이터가 아닌 프로그램이 실행되는 동안 유지되어야 할 데이터가 저장되는 공간이다.

// ex) 전역 변수, 정적 변수, 문자열 상수, 전역 배열, 전역 구조체, 상수 변수

// 데이터 영역 또한 위에서 언급한 것처럼 크기가 고정되어 있는 정적 할당 영역으로, 데이터 영역에 저장될 내용들은 프로그램 실행 동안 유지되는 내용들이기 때문이다.


// ## 힙 영역 ///////////////////////////////////////////

// 힙 영역은 프로그래머가 직접 할당할 수 있는 저장 공간이다.

// 프로그래밍 과정에서 힙 영역에 메모리 공간을 할당했다면 언젠가 반드시 해당 공간을 반환해야 한다.이는 운영체제에게 ‘더 이상 해당 메모리 공간을 사용하지 않겠다’라고 말해주는 것과 같다.

// 메모리를 반환하지 않으면 할당한 공간은 메모리 내에 계속 남아 메모리 낭비를 초래하는 문제를 발생시키는데, 이를 메모리 누수라 한다.

// 힙 영역 같은 경우 스택 영역과 함께 프로세스 실행 과정에서 그 크기가 변할 수 있는 영역, 동적 할당 영역이다.힙 영역 같은 경우에는 데이터가 낮은 주소에서 높은 주소로 할당이 된다.


// ## 스택 영역 /////////////////////////////////////////

// 스택 영역은 데이터를 일시적으로 저장하는 공간이다.데이터 영역과 달리 잠시 사용할 값들이 저장되는 공간이다.

// ex) 매개 변수, 지역 변수

// 스택 영역에 일시적으로 저장될 데이터는 PUSH되고, 더 이상 필요하지 않은 데이터는 POP됨으로써 스택 영역에서 영원히 사라진다.

// 스택 영역은 선입후출(LIFO, Last - In First - Out) 방식에 따라 동작하기 때문에 가장 먼저 들어온 데이터가 가장 나중에 인출된다.

// 위에서 언급한 바와 같이 스택 영역은 크기가 변할 수 있는 동적 할당 영역이다.스택 영역은 높은 주소에서 낮은 주소로 데이터가 할당이 된다.


// 힙 영역과 스택 영역은 서로 다른 방향으로 주소를 할당하여 데이터가 쌓여도 새롭게 할당되는 주소가 겹치지 않게 한다.