//////////////////////////////////////////////////////////
// [CPU 스케줄링 개요]
//////////////////////////////////////////////////////////

// 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것을 CPU 스케줄링이라 한다. CPU 스케줄링은 컴퓨터 성능과도 직결되는 부분이다.

//////////////////////////////////////////////////////////

// 프로세스 우선순위 ////////////////////////////////////////

// CPU 요청이 먼저 들어온 프로세스부터 처리하는 것은 그리 좋지 않은 방식이다.그 이유는 프로세스마다 우선순위가 다르기 때문이다.

// 우선순위가 높은 프로세스란 빨리 처리해야 하는 프로세스로, 대표적으로 입출력 작업이 많은 프로세스가 있다.

// - 입출력 집중 프로세스
//		- 입출력 작업이 많은 프로세스이다.
//		- 실행 상태보다 대기 상태에 더 많이 머물게 된다.
//		- ex) 비디오 재생, 디스크 백업 작업 담당하는 프로세스
// - CPU 집중 프로세스
//		- CPU 작업이 많은 프로세스이다.
//		- 대기 상태보다 실행 상태에 더 많이 머무는 프로세스이다.
//		- ex) 복잡한 수학 연산, 컴파일, 그래픽 처리 작업을 담당하는 프로세스

// CPU 집중 프로세스와 입출력 집중 프로세스가 동일한 빈도로 CPU를 사용하는 것은 비효율적이다.

// 상황에 맞게, 그리고 프로세스의 중요도에 맞게 프로세스가 CPU를 이용할 수 있도록 하기 위해 운영체제는 프로세스마다 우선순위를 부여한다.

// 운영체제는 각 프로세스의 PCB에 우선순위를 명시라고, PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정한다.

//////////////////////////////////////////////////////////

// 스케줄링 큐 /////////////////////////////////////////////

// PCB에 우선순위가 적혀 있다고 하긴 했으나, CPU를 사용할 다음 프로세스를 찾기 위해 운영체제가 일일이 모든 프로세스의 PCB를 뒤적거리는 것은 비효율적이다.

// CPU를 원하는 프로세스의 양이 적은 것이 아니며, CPU를 요구하는 프로세스는 언제든 생길 수 있기 때문이다.

// 그래서 운영체제는 프로세스들에 ‘줄을 서서 기다릴 것’을 요구한다.운영체제는 이 줄을 스케줄링 큐* 로 구현하고 관리한다.

// * 큐는 자료 구조 관점으로 보았을 때는 먼저 삽입한 데이터가 먼저 나가는 선입선출(FIFO - First In First Out) 자료 구조지만, 스케줄링에서 이야기하는 큐는 반드시 선입선출 방식일 필요는 없다.

// 즉, 운영체제는 메모리로 적재되고 싶은(새로 생성되는) 프로세스들을 큐에 삽입하여 줄을 세우고, CPU를 이용하고 싶어하는 프로세스들 또한 줄을 세우고, 특정 입출력장치를 이용하고 싶어하는 프로세스 또한 큐에 삽입하여 줄을 세운다.

//////////////////////////////////////////////////////////

// 운영체제가 관리하는 대부분은 이렇게 큐로 관리된다.이런 큐에는 다양한 종류가 있는데 대표적은 큐로 준비 큐와 대기 큐가 있다.

// 여기서 준비 큐란 CPU를 이용하고 싶어하는 프로세스들이 서는 줄을, 대기 큐는 입출력장치를 이용하기 위해 대기 상태에 들어간 프로세스들이 서는 줄을 의미한다.

// -준비 큐
//		- 준비 상태에 있는 프로세스들의 PCB는 준비 큐의 마지막에 삽입되어 CPU를 사용할 차례를 기다린다.
//		- 운영체제는 PCB들이 큐에 삽입된 순서대로 프로세스들을 하나씩 꺼내서 실행하되, 그중 우선순위가 높은 프로세스는 먼저 실행한다.

// - 대기 큐
//		- 대기 큐도 준비 큐처럼 같은 장치를 요구한 프로세스들은 같은 대기 큐에서 기다린다.
//		- 입출력이 완료되면 완료 인터럽트가 발생하고 운영체제는 대기 큐에서 작업이 완료된 PCB를 찾고, 이 PCB를 준비 상태로 변경한 뒤 대기 큐에서 제거한다.해당 PCB는 준비 큐로 이동한다.

//////////////////////////////////////////////////////////

// 선점형과 비선점형 스케줄링 ////////////////////////////////

// - 선점형 스케줄링
//		- 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에게 할당할 수 있는 스케줄링 방식이다.
//		- 하나의 프로세스가 자원을 독점할 수 없는 스케줄링 방식이다.
//		- 자원 독점을 막고 프로세스들에게 골고루 자원을 배분할 수 있다는 장점을 가지고 있으나, 그만큼 문맥 교환에서 오버헤드가 발생할 수 있다.

// -비선점형 스케줄링
//		- 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까지는 다른 프로세스가 끼어들 수 없는 스케줄링 방식이다.
//		- 하나의 프로세스가 자원을 독점할 수 있는 스케줄링 방식이다.
//		- 문맥 교환의 횟수가 선점형 스케줄링에 비해 적어 문맥 교환으로 인한 오버헤드가 선점형 스케줄링보다 적게 발생하지만, 자원 독점으로 인해 당장 자원이 필요한 상황에서도 무작정 기다려야 한다는 단점이 있다.

// 현재 대부분의 운영체제는 선점형 스케줄링 방식을 사용하고 있다.