//////////////////////////////////////////////////////////
// [CPU 스케줄링 알고리즘]
//////////////////////////////////////////////////////////


// [ 스케줄링 알고리즘의 종류 ] //////////////////////////////

// 스케줄링 알고리즘의 종류는 매우 다양하며 운영체제 저마다 다른 스케줄링 알고리즘을 사용하고 있다.여기서는 일곱 가지 스케줄링 알고리즘을 알아볼 예정이다.


// ## 선입 선처리 스케줄링(FCFS 스케줄링) ////////////////////

// 선입 선처리 스케줄링이란 단순히 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식이다.

// 언뜻 보기에는 가장 공정해 보이지만, 때때로 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 점에서 부작용이 있는 방식이다.

// CPU를 오래 사용하는 프로세스가 먼저 도착하면 다른 프로세스는 그 프로세스가 CPU를 사용하는 동안 무작정 기다리는 수밖에 없다.이런 현상을 호위 효과라 한다.
//////////////////////////////////////////////////////////

// ## 최단 작업 우선 스케줄링(SJF 스케줄링) ///////////////////

// 최단 작업 우선 스케줄링이란 준비 큐에 삽입된 프로세스들 중 CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행하는 스케줄링 방식이다.

// 기본적으로 비선점형 스케줄링 알고리즘으로 분류되지만, 선점형으로 구현될 수 있다.
//////////////////////////////////////////////////////////

// ## 라운드 로빈 스케줄링 //////////////////////////////////

// 라운드 로빈 스케줄링은 선입 선처리 스케줄링에 타임 슬라이스라는 개념이 더해진 스케줄링 방식이다.

// 타임 슬라이스란 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미한다.

// 즉, 라운드 로빈 스케줄링이란 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용할 수 있는 선점형 스케줄링이다.

// 타임 슬라이스가 지나치게 크면 사실상 선입 선처리 스케줄링 방식과 다를 바 없이 호위 효과가 생길 여지가 있고, 타임 슬라이스가 지나치게 작으면 문맥 교환에 발생하는 비용이 커 CPU는 프로세스를 처리하는 일보다 프로세스를 전환하는 데에 집중된다.
//////////////////////////////////////////////////////////

// ## 최소 잔여 시간 우선 스케줄링(SRT 스케줄링) //////////////

// 최소 잔여 시간 우선 스케줄링은 최단 작업 우선 알고리즘과 라운드 로빈 알고리즘을 합친 방식이다.

// 프로세스들은 정해진 타임 슬라이스만큼 CPU룰 사용하되, CPU를 사용할 다음 프로세스로 남아있는 작업 시간이 가장 적은 프로세스가 선택된다.
//////////////////////////////////////////////////////////

// ## 우선순위 스케줄링 /////////////////////////////////////

// 우선순위 스케줄링은 프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 알고리즘이다.

// 우선순위가 높은 프로세스를 우선하여 처리하는 방식이기에 우선순위가 낮은 프로세스는 준비 큐에 먼저 삽입되었음에도 불구하고 우선순위가 높은 프로세스에 의해 실행이 계속 연기될 수 있다.이러한 현상을 기아 현상이라 한다.

// 이러한 기아 현상을 방지하기 위해 사용하는 기법으로 에이징이 있다.에이징이란 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식이다.
//////////////////////////////////////////////////////////

// ## 다단계 큐 스케줄링 ////////////////////////////////////

// 다단계 큐 스케줄링은 우선순위 스케줄링의 발전된 형태로, 우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식이다.

// 우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고, 우선순위가 가장 높은 큐가 비어 있으면 그다음 우선순위 큐에 있는 프로세스들을 처리한다.

// 이렇게 큐를 여러 개 두면 프로세스 유형별로 우선순위를 구별하여 실행하는 것이 편리해진다.

// 또한 큐별로 타입 슬라이스를 여러 개 지정할 수 있고, 큐마다 다른 스케줄링 알고리즘을 사용할 수 있다.

// 다단계 큐 스케줄링은 프로세스들이 큐 사이를 이동할 수 없다.
//////////////////////////////////////////////////////////

// ## 다단계 피드백 큐 스케줄링 //////////////////////////////

// 다단계 큐 스케줄링은 프로세스들이 큐 사이를 이동할 수 없기 때문에 기아 현상이 발생할 수 있다.이를 보완하기 위해 스케줄링 알고리즘이 다단계 피드백 큐 스케줄링이다.

// 다단계 피드백 큐 스케줄링은 다단계 큐 스케줄링과 비슷하게 작동하지만, 프로세스들이 큐 사이를 이동할 수 있다.

// - 다단계 피드백 큐 스케줄링에서 새로 준비 상태가 된 프로세스가 있다면 우선 우선순위가 가장 높은 큐에 삽입되고 일정 시간(타임 슬라이스)동안 실행된다.
// - 만약 프로세스가 해당 큐에서 실행이 끝나지 않는다면 다음 우선순위 큐에 삽입되어 실행된다.
// → CPU를 오래 사용하는 프로세스는 점차 우선순위가 낮아진다.
// - 즉, CPU 집중 프로세스들은 자연스럽게 우선순위가 낮아지고, 입출력 집중 프로세스들은 자연스레 우선순위가 높은 큐에서 실행이 끝난다.
// - 낮은 우선순위 큐에 프로세스가 너무 오래 기다리고 있다면 우선순위가 높은 큐로 이동시키는 에이징 기법을 적용한다.

// 다단계 피드백 큐 프로세스 알고리즘은 어떤 프로세스의 CPU 이용 시간이 길면 낮은 우선순위 큐로 이동시키고, 어떤 프로세스가 낮은 우선순위 큐에서 너무 오래 기다리면 높은 우선순위 큐로 이동시킬 수 있는 알고리즘이다.

// 가장 구현하기 복잡하지만, 가장 일반적인 CPU 스케줄링 알고리즘이다.