//////////////////////////////////////////////////////////
// [페이징을 통한 가상 메모리 할당]
//////////////////////////////////////////////////////////

// 앞서 언급한 것처럼 프로세스의 메모리 연속 할당 방식에는 물리 메모리보다 큰 프로세스를 실행할 수 없다는 단점이 있다.

// 가상 메모리는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술이다.

// 이를 가능하게 하는 가상 메모리 기법에는 크게 페이징과 세그멘테이션이 있지만, 현대 대부분의 운영체제는 페이징 기법을 사용한다.

// [ 페이징이란 ] //////////////////////////////////////////

// 연속 메모리 할당 방식이 외부 단편화가 생기는 근본적인 이유는 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문이다.

// → 메모리를 일정 단위로 자르고, 이를 메모리에 불연속적으로 할당할 수 있다면 외부 단편화는 발생하지 않는다.이러한 방식을 페이징이라 한다.

// 페이징은 프로세스의 논리 주소 공간을 페이지라는 단위로 자르고, 메모리 물리 주소 공간을 프레임이라는 페이지와 동일한 크기와 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법이다.

// 페이징에서도 스와핑을 사용할 수 있다.

// 페이징을 사용하는 시스템에서는 페이지 단위로 스왑 아웃 / 스왑 인된다.

// 페이징 시스템에서는 스왑 아웃을 페이지 아웃, 스왑 인을 페이지 인이라 부른다.

// 이를 다르게 말하면 한 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요가 없다는 말과 같다.이러한 방식을 통해 물리 메모리보다 더 큰 프로세스를 실행할 수 있다.

//////////////////////////////////////////////////////////

// [ 페이지 테이블 ] ///////////////////////////////////////

// 프로세스가 메모리에 불연속적으로 배치되어 있으면 CPU 입장에서 이를 순차적으로 실행할 수 없다.

// 즉, CPU 입장에서는 다음에 실행할 명령어의 위치를 찾기 어려워진다.

// 이를 해결하기 위해 페이징 시스템은 프로세스가 비록 물리 주소에 불연속적으로 배치되어 있다 하더라도 CPU가 바라보는 주소인 논리 주소에서는 연속적으로 배치되도록 페이지 테이블을 이용한다.

// 페이지 테이블은 페이지 번호와 프레임 번호를 짝 지어주는 일종의 이정표이다.

// → 페이지 테이블은 현재 어떤 페이지가 어떤 프레임에 할당되어 있는지 알려준다.

// 이러한 방식을 통해 프로세스들이 메모리에 분산되어 저장되어 있더라도 CPU는 논리 주소를 그저 순차적으로 실행하면 된다.

// 내부 단편화 ----------------------------------------------
/*
페이징은 외부 단편화를 해결할 수 있지만, 내부 단편화를 야기할 수 있다.

페이징은 프로세스의 논리 주소를 페이지라는 일정한 크기 단위로 자른다.허나 모든 프로세스가 페이지 크기에 딱 맞게 잘리는 것은 아니다. (프로세스 크기가 페이지 크기의 배수는 X)

이런 경우 마지막 페이지에서 메모리가 남는 경우가 발생하는데, 이러한 메모리 낭비를 내부 단편화라 한다.

내부 단편화는 하나의 페이지 크기보다 작은 크기로 발생한다.그렇기에 하나의 페이지 크기가 작으면 내부 단편화의 크기가 작아지는 것을 기대할 수 있다.

하지만 페이지 크기가 작으면 그만큼 페이지 테이블 크기도 커지기에 페이지 테이블이 차지하는 공간이 낭비된다.

일부 운영체제(ex) 리눅스)에서는 기본적으로 설정된 페이지 크기보다 더 큰 크기의 페이지인 대형 페이지도 일부 허용하며 메모리에 유지하는 경우도 있다.
-------------------------------------------------------- */

// 프로세스마다 각자의 프로세스 테이블을 가지고 있고 각 프로세스의 페이지 테이블들은 메모리에 적재되어 있다.

// 그리고 CPU 내의 페이지 테이블 베이스 레지스터(PTBR)는 각 프로세스의 페이지 테이블이 적재된 주소를 가리키고 있다.*

// * 각 프로세스들의 페이지 테이블 정보들은 각 프로세스의 PCB에 기록된다.그리고 프로세스의 문맥 교환이 일어날 때 다른 레지스터와 마찬가지로 함께 변경된다.

//////////////////////////////////////////////////////////

// 페이지 테이블을 메모리에 두면 메모리 접근 시간이 두 배로 늘어난다는 문제가 생긴다.

// 1) 메모리에 있는 페이지 테이블을 보기 위해 한 번, 2) 그렇게 알게 된 프레임에 접근하기 위해 한 번, 총 두 번의 메모리 접근이 필요하다.

// 이러한 문제를 해결하기 위해 CPU 곁에(일반적으로 MMU 내에) TLB라는 페이지 테이블의 캐시 메모리를 둔다.

// TLB는 페이지 테이블의 캐시이기 때문에 페이지 테이블의 일부 내용을 저장하며, 참조 지역성에 근거한다.

// - TLB 히트
//		 - CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있는 경우이다.
// - TLB 미스
//		- 페이지 번호가 TLB에 없어 메모리 내의 페이지 테이블에 접근해야 하는 경우이다.

//////////////////////////////////////////////////////////

// [ 페이징에서의 주소 변환 ] ///////////////////////////////

// 하나의 페이지 혹은 프레임의 특정 주소에 접근하려면 두 가지의 정보가 필요하다.

// - 어떤 페이지 혹은 프레임에 접근하고 싶은가.
// - 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는가.

// 페이징 시스템에서 모든 논리 주소가 기본적으로 페이지 번호와 변위로 이루어져 있다.

// - 페이지 번호
//		- 접근하고자 하는 페이지 번호이다.
//		- 페이지 테이블에서 해당 페이지 번호를 찾으면 페이지가 어떤 프레임에 할당되어 있는지 알 수 있다.
// - 변위
//		- 접근하려는 주소가 프레임의 시작 번지로부터 얼마나 떨어져 있는지를 알기 위한 정보이다.

// 논리 주소<페이지 번호, 변위>는 페이지 테이블을 통해 물리 주소<프레임 번호, 변위>로 변환된다.*

// * 논리 주소의 변위와 물리 주소의 변위 값은 같다.

//////////////////////////////////////////////////////////

// [ 페이지 테이블 엔트리 ] /////////////////////////////////

// 페이지 테이블의 각각의 행들을 페이지 테이블 엔트리라 한다.(PTE)

// 페이지 테이블 엔트리에 담긴 정보로는 페이지 번호, 프레임 번호 외에도 다른 중요한 정보들이 담기며, 대표적으로 유효 비트, 보호 비트, 참조 비트, 수정 비트가 있다.

// ## 유효 비트 ///////////////////////////////////////////

// 유효 비트는 현재 해당 페이지에 접근이 가능한지 여부를 알려주는 비트로, 프레임 번호 다음으로 중요한 정보이다.

// 유효 비트는 현재 페이지가 메모리에 적재되어 있는지 아니면 보조기억장치에 있는지를 알려주는 비트이다.

// - 페이지가 메모리에 적재되어 있다.→ 유효 비트 1
// - 페이지가 메모리에 적재되어 있지 않다.(보조기억장치에 있다) → 유효 비트 0

// 유효 비트가 0인데 해당 페이지에 접근하려고 하면 페이지 폴트라는 예외가 발생한다.

// 페이지 폴트를 처리하는 과정은 하드웨어 인터럽트 처리 과정과 유사하다.

// 1. CPU는 기존의 작업을 백업한다.
// 2. 페이지 폴트 처리 루틴을 실행한다.
// 3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경해 준다.
// 4. 페이지 폴트를 처리했다면 이제 CPU는 해당 페이지에 접근할 수 있다.

//////////////////////////////////////////////////////////

// ## 보호 비트 ///////////////////////////////////////////

// 보호 비트는 페이지 보호 기능을 위해 존재하는 비트이다.

// 보호 비트를 통해 해당 페이지가 읽고 쓰기가 모두 가능한 페이지인지, 혹은 읽기만 가능한 페이지인지를 나타낼 수 있다.

// - 보호 비트가 1 → 읽고 쓰기가 모두 가능한 페이지이다.
// - 보호 비트가 0 → 읽기만 가능한 페이지이다.

// 보호 비트는 세 개의 비트를 통해 좀 더 복잡하게 구현할 수 있다.

// 읽기를 나타내는 r, 쓰기를 나타내는 w, 실행을 나타내는 x의 조합으로 읽기, 쓰기, 실행 권한을 나타낸다.

//////////////////////////////////////////////////////////

// ## 참조 비트 ///////////////////////////////////////////

// 참조 비트는 CPU가 해당 페이지를 참조한 적이 있는지 여부를 나타낸다.

// - 적재 이후 CPU가 읽거나 쓴 페이지 → 참조 비트 1
// - 적재 이후 한 번도 읽거나 쓴 적이 없는 페이지 → 참조 비트 0으로 유지

//////////////////////////////////////////////////////////

// ## 수정 비트 ///////////////////////////////////////////

// 수정 비트는 해당 페이지에 데이터를 쓴 적이 있는지 여부를 알려주는 비트이며, 더티 비트라 불리기도 한다.

// - 수정 비트가 1 → 변경된 적이 있는 페이지
// - 수정 비트가 0 → 한 번도 접근한 적이 없거나 읽기만 했던 페이지, 즉 변경된 적이 없는 페이지

// 수정 비트는 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야 하는지, 할 필요가 없는지 판단하기 위해 존재한다.

//////////////////////////////////////////////////////////

// [ 페이징의 이점 - 쓰기 시 복사 ] //////////////////////////

// 페이징이 제공하는 장점에는 대표적으로 프로세스 간 페이지를 공유할 수 있다는 점이 있다.

// 프로세스 간 페이지를 곻유하는 사례로는 공유 라이브러리 등 다양하지만, 대표적으로 쓰기 시 복사가 있다.

// 유닉스 / 리눅스 계열이 OS에서 fork 시스템 호출을 하면 부모 프로세스의 복사본이 자식 프로세스로서 만들어진다.
 
// 새롭게 생성된 자식 프로세스의 코드 및 데이터 영역은 부모 프로세스가 적재된 메모리 공간과는 전혀 다른 메모리 공간에 생성된다.
 
// → 이러한 복사 작업은 프로세스 생성 시간을 늦출 뿐만 아니라 불필요한 메모리 낭비를 야기한다.
 
// 쓰기 시 복사에서는 부모 프로세스와 동일한 자식 프로세스가 생성되면 자식 프로세스로 하여금 부모 프로세스와 동일한 프로세스와 동일한 프레임을 가진다.
 
// 만일 부모 프로세스와 자식 프로세스가 메모리에 어떠한 데이터도 쓰지 않고 그저 읽기 작업만 이어 나가다면 이 상태가 지속된다.
 
// 부모 프로세스와 자식 프로세스 둘 중 하나가 페이지에 쓰기 작업을 하면 그 순간 페이지가 별도의 공간으로 복제되며, 각 프로세스는 자신의 공유한 페이지가 할당된 프레임을 가리킨다.
 
// → 이러한 쓰기 시 복사를 통해 프로세스 생성 시간을 줄이는 것은 물론 메모리 공간 절약도 가능하다.

//////////////////////////////////////////////////////////

// [ 계층적 페이징(다단계 페이지 테이블 기법) ] ////////////////

//프로세스를 이루는 모든 페이지 테이블 엔트리를 메모리에 두는 것은 큰 메모리 낭비이다.

//계층적 페이징이란 프로세스를 이루는 모든 페이지 테이블 엔트리를 항상 메모리에 유지하지 않을 수 있는 방법이다.

//계층적 페이징은 페이지 테이블을 페이징하여 여러 단계의 페이지를 두는 방식이다.

//페이지 테이블을 여러 개의 페이지로 쪼개고, 이 페이지들을 가리키는 페이지 테이블(Outer 페이지 테이블)을 두는 방식이다.

//페이지 테이블 중 몇 개는 보조기억장치에 있어도 무방하며, 추후 해당 페이지 테이블을 참조해야 할 때 메모리에 적재하면 된다.→ 메모리 공간 낭비를 줄일 수 있다.

//다만 CPU와 가장 가까이 위치한 페이지 테이블(Outer 페이지 테이블)은 항상 메모리에 유지해야 한다.

//페이지 테이블의 계층은 세 개, 네 개, 그 이상의 계층으로 구성될 수 있다.다만 페이지 테이블의 계층이 늘어날수록 페이지 폴트가 발생했을 경우 메모리 참조 횟수가 많아지므로 계층이 많다고 해서 반드시 좋다고 볼 수 없다.